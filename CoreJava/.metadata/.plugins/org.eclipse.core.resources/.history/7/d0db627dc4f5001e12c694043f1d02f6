package binarySearch;

public class RotationalBinary {
	
	//this will not work for duplicate values
	public static void main(String[] args) {
		int []arr = {3,5,1};
		int t = 3;
		int maxNumIndex1 = findPivot(arr);
		int maxNumIndex = MountainArray.getPeakIndex(arr);
		System.out.println("peekIndex "+maxNumIndex);
		if(arr[maxNumIndex] == t)
			System.out.println(maxNumIndex);
		//if we do not find pivot its not rotational so do normal binarysearch
		if(maxNumIndex==-1) {
			int index = valIndex(arr, t, 0, arr.length-1);
			System.out.println(index);
		}
		
		else if(t<=arr[0]) {
			int index = valIndex(arr, t, maxNumIndex+1, arr.length-1);
			System.out.println(index);
		}else {
			int index = valIndex(arr, t, 0, maxNumIndex);
			System.out.println(index);
		}
		
		
	}
	//find the highest number in the array
	static int findPivot(int[] arr) {
		int start = 0;
		int end =  arr.length-1;
		while(start<=end) {
			int m = start+(end-start)/2;
			if(m<end && arr[m]>arr[m+1]) {
				return m;
			}if(m>start && arr[m]<arr[m-1]) {
				return m-1;
			}
			if(arr[m]<=arr[start]) {
				end = m-1;
			}else {
				start=m+1;
			}
		}
		return -1;
	}
	
	 static int valIndex (int [] arr,int t, int s, int e) {
		
			 while(s<=e) {
				 int m = s+(e-s)/2;
				 if(arr[m]>t) {
					 e= m-1;
				 }else if(arr[m]<t) {
					 s = m+1;
				 }else {
					 return m;
				 }
			 }
			 return -1;
		 }

}
